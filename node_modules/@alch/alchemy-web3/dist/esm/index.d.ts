import Web3 from "web3";
import { Log, LogsOptions, Transaction } from "web3-core";
import { Subscription } from "web3-core-subscriptions";
import { BlockHeader, Eth, Syncing } from "web3-eth";
import { AlchemyWeb3Config, Provider, TransactionsOptions, Web3Callback } from "./types";
export interface AlchemyWeb3 extends Web3 {
    alchemy: AlchemyMethods;
    eth: AlchemyEth;
    setWriteProvider(provider: Provider | null | undefined): void;
}
export interface AlchemyMethods {
    getTokenAllowance(params: TokenAllowanceParams, callback?: Web3Callback<TokenAllowanceResponse>): Promise<TokenAllowanceResponse>;
    getTokenBalances(address: string, contractAddresses: string[], callback?: Web3Callback<TokenBalancesResponse>): Promise<TokenBalancesResponse>;
    getTokenMetadata(address: string, callback?: Web3Callback<TokenMetadataResponse>): Promise<TokenMetadataResponse>;
    getAssetTransfers(params: AssetTransfersParams, callback?: Web3Callback<AssetTransfersResponse>): Promise<AssetTransfersResponse>;
    getNftMetadata(params: NftMetadataParams, callback?: Web3Callback<NftMetadataResponse>): Promise<NftMetadataResponse>;
}
export interface TokenAllowanceParams {
    contract: string;
    owner: string;
    spender: string;
}
export declare type TokenAllowanceResponse = string;
export interface TokenBalancesResponse {
    address: string;
    tokenBalances: TokenBalance[];
}
export declare type TokenBalance = TokenBalanceSuccess | TokenBalanceFailure;
export interface TokenBalanceSuccess {
    address: string;
    tokenBalance: string;
    error: null;
}
export interface TokenBalanceFailure {
    address: string;
    tokenBalance: null;
    error: string;
}
export interface TokenMetadataResponse {
    decimals: number | null;
    logo: string | null;
    name: string | null;
    symbol: string | null;
}
export interface AssetTransfersParams {
    fromBlock?: string;
    toBlock?: string;
    order?: AssetTransfersOrder;
    fromAddress?: string;
    toAddress?: string;
    contractAddresses?: string[];
    excludeZeroValue?: boolean;
    maxCount?: number;
    category?: AssetTransfersCategory[];
    pageKey?: string;
}
export declare enum AssetTransfersCategory {
    EXTERNAL = "external",
    INTERNAL = "internal",
    TOKEN = "token",
    ERC20 = "erc20",
    ERC721 = "erc721",
    ERC1155 = "erc1155"
}
export declare enum AssetTransfersOrder {
    ASCENDING = "asc",
    DESCENDING = "desc"
}
export interface AssetTransfersResponse {
    transfers: AssetTransfersResult[];
    pageKey?: string;
}
export interface AssetTransfersResult {
    category: AssetTransfersCategory;
    blockNum: string;
    from: string;
    to: string | null;
    value: number | null;
    erc721TokenId: string | null;
    erc1155Metadata: ERC1155Metadata[] | null;
    asset: string | null;
    hash: string;
    rawContract: RawContract;
}
export interface NftMetadataParams {
    contractAddress: string;
    tokenId: string;
    tokenType: "erc721" | "erc1155";
}
export interface NftMetadataResponse {
    contract: string;
    tokenType: "erc721" | "erc1155";
    tokenId: string;
    rawMetadataUri: string | null;
    alchemyMetadataUri: string | null;
    rawImageUri: string | null;
    alchemyImageUri: string | null;
    name: string | null;
    description: string | null;
    attributes: [Record<string, any>] | null;
    rawMetadata: Record<string, any>;
}
export interface ERC1155Metadata {
    tokenId: string;
    value: string;
}
export interface RawContract {
    value: string | null;
    address: string | null;
    decimal: string | null;
}
/**
 * Same as Eth, but with `subscribe` allowing more types.
 */
export interface AlchemyEth extends Eth {
    subscribe(type: "logs", options?: LogsOptions, callback?: (error: Error, log: Log) => void): Subscription<Log>;
    subscribe(type: "syncing", callback?: (error: Error, result: Syncing) => void): Subscription<Syncing>;
    subscribe(type: "newBlockHeaders", callback?: (error: Error, blockHeader: BlockHeader) => void): Subscription<BlockHeader>;
    subscribe(type: "pendingTransactions", callback?: (error: Error, transactionHash: string) => void): Subscription<string>;
    subscribe(type: "alchemy_fullPendingTransactions", callback?: (error: Error, transaction: Transaction) => void): Subscription<Transaction>;
    subscribe(type: "alchemy_filteredFullPendingTransactions", options?: TransactionsOptions, callback?: (error: Error, transaction: Transaction) => void): Subscription<Transaction>;
    subscribe(type: "pendingTransactions" | "logs" | "syncing" | "newBlockHeaders" | "alchemy_fullPendingTransactions" | "alchemy_filteredFullPendingTransactions", options?: null | LogsOptions | TransactionsOptions, callback?: (error: Error, item: Log | Syncing | BlockHeader | string | Transaction) => void): Subscription<Log | BlockHeader | Syncing | string>;
}
export declare function createAlchemyWeb3(alchemyUrl: string, config?: AlchemyWeb3Config): AlchemyWeb3;
